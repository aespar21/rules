% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cubist.R
\name{cubist_rules}
\alias{cubist_rules}
\alias{update.cubist_rules}
\title{General Interface for Cubist Rule-Based Regression Models}
\usage{
cubist_rules(
  mode = "regression",
  committees = NULL,
  neighbors = NULL,
  max_rules = NULL
)

\method{update}{cubist_rules}(
  object,
  parameters = NULL,
  committees = NULL,
  neighbors = NULL,
  max_rules = NULL,
  fresh = FALSE,
  ...
)
}
\arguments{
\item{mode}{A single character string for the type of model.
The only possible value for this model is "regression".}

\item{committees}{A non-negative integer (no greater than 100 for the number
of members of the ensemble.}

\item{neighbors}{An integer between zero and nine for the number of training
set instances that are used to adjust the model-based prediction.}

\item{max_rules}{The largest number of rules.}

\item{object}{A Cubist model specification.}

\item{parameters}{A 1-row tibble or named list with \emph{main} parameters to update.
If the individual arguments are used, these will supersede the values in
parameters. Also, using engine arguments in this object will result in an
error.}

\item{fresh}{A logical for whether the arguments should be modified in-place
or replaced wholesale.}

\item{...}{Not used for \code{update()}.}
}
\description{
\code{\link[=cubist_rules]{cubist_rules()}} is a way to generate a \emph{specification} of a model
before fitting. The main arguments for the model are:
\itemize{
\item \code{committees}: The number of sequential models included in the
ensemble (similar to the number of trees in boosting).
\item \code{neighbors}: The number of neighbors in the post-model
instance-based adjustment.
}
These arguments are converted to their specific names at the
time that the model is fit. Other options and argument can be
set using \code{\link[parsnip:set_engine]{parsnip::set_engine()}}. If left to their defaults
here (\code{NULL}), the values are taken from the underlying model
functions. If parameters need to be modified, \code{update()} can be used
in lieu of recreating the object from scratch.
}
\details{
The only availible engine is \code{"Cubist"}.
}
\section{Engine Details}{


Engines may have pre-set default arguments when executing the
model fit call. For this type of
model, the template of the fit calls are:

\pkg{Cubist}
}

\examples{
cubist_rules()
# Parameters can be represented by a placeholder:
cubist_rules(committees = 7)

# ------------------------------------------------------------------------------

data(car_prices, package = "modeldata")
car_rules <-
  cubist_rules(committees = 1) \%>\%
  fit(log10(Price) ~ ., data = car_prices)

car_rules

summary(car_rules$fit)

# ------------------------------------------------------------------------------

model <- cubist_rules(committees = 10, neighbors = 2)
model
update(model, committees = 1)
update(model, committees = 1, fresh = TRUE)
}
\seealso{
\code{\link[parsnip:fit]{parsnip::fit()}}, \code{\link[parsnip:set_engine]{parsnip::set_engine()}}
}
